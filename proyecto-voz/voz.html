<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mural de Voz - English Voice Wall</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, 
                #8B4513 0%, #CD853F 15%, #DC143C 35%, 
                #FFD700 50%, #FF8C00 65%, #228B22 85%, #8B4513 100%
            );
            background-image: url('../2html.jpg');
            background-size: 100% 100%;
            background-position: center;
            background-repeat: no-repeat;
            background-attachment: scroll;
            min-height: 100vh;
            color: white;
            padding: 20px;
            position: relative;
            overflow-x: hidden;
        }
        
        body::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.3);
            z-index: 0;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            position: relative;
            z-index: 2;
        }
        
        .header {
            text-align: center;
            margin-bottom: 40px;
        }
        
        .header h1 {
            font-size: 3em;
            margin-bottom: 10px;
            text-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }
        
        .header p {
            font-size: 1.2em;
            opacity: 0.9;
            margin-bottom: 20px;
        }

        .social-links {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 30px;
        }

        .social-link {
            display: inline-block;
            background: linear-gradient(135deg, 
                rgba(220, 20, 60, 0.15) 0%, 
                rgba(255, 140, 0, 0.12) 30%,
                rgba(255, 165, 0, 0.15) 60%,
                rgba(178, 34, 34, 0.12) 100%);
            backdrop-filter: blur(15px) saturate(120%);
            padding: 12px 24px;
            border-radius: 50px;
            text-decoration: none;
            color: white;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 
                0 8px 25px rgba(220, 20, 60, 0.15),
                0 4px 15px rgba(255, 140, 0, 0.12);
            border: 2px solid rgba(255, 140, 0, 0.3);
        }

        .social-link:hover {
            transform: translateY(-3px);
            background: rgba(255, 255, 255, 0.2);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
        }

        .voice-recorder {
            background: linear-gradient(135deg, 
                rgba(220, 20, 60, 0.12) 0%, 
                rgba(255, 140, 0, 0.10) 30%,
                rgba(255, 165, 0, 0.12) 60%,
                rgba(178, 34, 34, 0.10) 100%);
            border-radius: 50%;
            width: 200px;
            height: 200px;
            backdrop-filter: blur(20px) saturate(120%);
            box-shadow: 
                0 15px 50px rgba(220, 20, 60, 0.2),
                0 10px 30px rgba(255, 140, 0, 0.15);
            margin: 0 auto 40px auto;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
            border: 3px solid rgba(255, 140, 0, 0.4);
        }

        .voice-recorder::before {
            content: '';
            position: absolute;
            top: -3px;
            left: -3px;
            right: -3px;
            bottom: -3px;
            border-radius: 50%;
            background: linear-gradient(45deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            z-index: -1;
            animation: shimmer 4s linear infinite;
        }

        .record-button {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            border: none;
            background: linear-gradient(45deg, #FF6B6B, #FF8E53);
            color: white;
            font-size: 2em;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 6px 20px rgba(255, 107, 107, 0.4);
            margin-bottom: 10px;
        }

        .record-button:hover {
            transform: scale(1.1);
            box-shadow: 0 8px 25px rgba(255, 107, 107, 0.6);
        }

        .record-button.recording {
            background: linear-gradient(45deg, #ff4757, #ff3838);
            animation: pulse 1.5s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        .recording-status {
            font-size: 0.9em;
            margin-top: 8px;
            opacity: 0.8;
            text-align: center;
        }

        .mobile-canvas {
            width: 100%;
            height: 200px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            margin: 20px 0;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .voice-wall {
            position: relative;
            min-height: 600px;
            margin-top: 40px;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            align-items: flex-start;
            gap: 20px;
            padding: 40px;
        }

        .voice-bubble {
            position: relative;
            width: 180px;
            height: 180px;
            border-radius: 50%;
            backdrop-filter: blur(15px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
            transition: all 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
            text-align: center;
            animation: float 6s ease-in-out infinite;
            margin: 10px;
        }

        .voice-bubble:hover {
            transform: scale(1.1) translateY(-10px);
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
        }

        .voice-bubble::before {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            border-radius: 50%;
            background: linear-gradient(45deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            z-index: -1;
            animation: shimmer 3s linear infinite;
        }

        @keyframes float {
            0%, 100% { transform: translateY(0px) rotate(0deg); }
            25% { transform: translateY(-10px) rotate(1deg); }
            50% { transform: translateY(-5px) rotate(-1deg); }
            75% { transform: translateY(-15px) rotate(0.5deg); }
        }

        @keyframes shimmer {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .bubble-color-1 { background: rgba(255, 107, 107, 0.15); border: 2px solid rgba(255, 107, 107, 0.3); }
        .bubble-color-2 { background: rgba(78, 205, 196, 0.15); border: 2px solid rgba(78, 205, 196, 0.3); }
        .bubble-color-3 { background: rgba(255, 206, 84, 0.15); border: 2px solid rgba(255, 206, 84, 0.3); }
        .bubble-color-4 { background: rgba(162, 155, 254, 0.15); border: 2px solid rgba(162, 155, 254, 0.3); }
        .bubble-color-5 { background: rgba(255, 118, 117, 0.15); border: 2px solid rgba(255, 118, 117, 0.3); }
        .bubble-color-6 { background: rgba(89, 171, 227, 0.15); border: 2px solid rgba(89, 171, 227, 0.3); }
        .bubble-color-7 { background: rgba(129, 236, 236, 0.15); border: 2px solid rgba(129, 236, 236, 0.3); }
        .bubble-color-8 { background: rgba(255, 159, 243, 0.15); border: 2px solid rgba(255, 159, 243, 0.3); }

        .voice-time {
            font-size: 0.7em;
            opacity: 0.8;
            margin-bottom: 8px;
            font-weight: 500;
        }

        .timer-overlay {
            position: absolute;
            bottom: -75px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.05);
            backdrop-filter: blur(5px);
            padding: 4px 8px;
            border-radius: 10px;
            font-size: 0.7em;
            font-weight: bold;
            z-index: 2;
            opacity: 0;
            transition: opacity 0.3s ease;
            color: rgba(255, 255, 255, 0.9);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .voice-bubble:hover .timer-overlay {
            opacity: 0.6;
        }




        .respond-button {
            position: absolute;
            bottom: -50px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.02);
            color: rgba(255, 255, 255, 0.6);
            border: 1px solid rgba(255, 255, 255, 0.08);
            padding: 6px 12px;
            border-radius: 15px;
            cursor: pointer;
            font-weight: bold;
            font-size: 0.7em;
            transition: all 0.3s ease;
            backdrop-filter: blur(20px);
            opacity: 0;
        }

        .voice-bubble:hover .respond-button {
            opacity: 0.5;
            transform: translateX(-50%) translateY(-5px);
        }

        .respond-button:hover {
            background: rgba(255, 255, 255, 0.05);
            opacity: 0.8;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.05);
        }

        @keyframes bubble-explosion {
            0% { 
                transform: scale(1) rotate(0deg);
                opacity: 1;
            }
            50% { 
                transform: scale(1.5) rotate(180deg);
                opacity: 0.5;
            }
            100% { 
                transform: scale(2) rotate(360deg);
                opacity: 0;
            }
        }

        .exploding {
            animation: bubble-explosion 0.8s ease-out forwards;
            pointer-events: none;
        }

        .instructions {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 30px;
            border-left: 4px solid #FFD700;
        }

        .instructions h3 {
            color: #FFD700;
            margin-bottom: 10px;
        }

        .instructions ul {
            list-style: none;
            padding-left: 20px;
        }

        .instructions li {
            margin: 8px 0;
            position: relative;
        }

        .instructions li::before {
            content: "🎤";
            position: absolute;
            left: -25px;
        }

        @media (max-width: 768px) {
            body {
                background-attachment: scroll;
                -webkit-overflow-scrolling: touch;
                background-size: cover !important;
            }
            
            .header h1 {
                font-size: 2.5em;
            }
            
            .voice-wall {
                grid-template-columns: 1fr;
            }

            .social-links {
                flex-direction: column;
                align-items: center;
            }
        }
        
        /* Efecto de hojas cayendo */
        .falling-leaves {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
        }
        
        .leaf {
            position: absolute;
            opacity: 0.2;
            font-size: 1.5em;
            animation: fall linear infinite;
        }
        
        .leaf:nth-child(odd) {
            color: #DC143C;
            animation-duration: 8s;
        }
        
        .leaf:nth-child(even) {
            color: #FF8C00;
            animation-duration: 12s;
        }
        
        .leaf:nth-child(3n) {
            color: #FFA500;
            animation-duration: 10s;
        }
        
        .leaf:nth-child(4n) {
            color: #B22222;
            animation-duration: 15s;
        }
        
        @keyframes fall {
            0% {
                transform: translateY(-100vh) rotate(0deg);
                opacity: 0.3;
            }
            10% {
                opacity: 0.2;
            }
            90% {
                opacity: 0.1;
            }
            100% {
                transform: translateY(100vh) rotate(360deg);
                opacity: 0;
            }
        }
    </style>
</head>
<body>
    <!-- Efecto de hojas cayendo -->
    <div class="falling-leaves" id="falling-leaves"></div>
    <div class="container">
        <div class="header">
            <h1>VoIcE MuRaL</h1>
            <p>😎</p>
            
            <div class="social-links">
                <a href="#" class="social-link" id="tiktok-link">
                    📍TikTok
                </a>
                <a href="#" class="social-link" id="youtube-link">
                    📍YouTube
                </a>
            </div>
        </div>

        
        <div class="voice-recorder">
            <button id="recordButton" class="record-button">🎤</button>
        </div>
        
        <canvas id="mobileCanvas" class="mobile-canvas" style="display: none;"></canvas>
        
        <div id="voiceWall" class="voice-wall">
            <!-- Voice bubbles will be dynamically added here -->
        </div>
    </div>

    <script>
        let mediaRecorder;
        let audioChunks = [];
        let isRecording = false;
        let recordingStartTime;
        let recordingTimer;
        let voiceNotes = new Map();
        let noteIdCounter = 1;
        let currentlyPlayingAudio = null; // Track currently playing audio
        const MAX_RECORDING_TIME = 30000; // 30 seconds
        const NOTE_LIFETIME = 10 * 60 * 1000; // 10 minutes
        const MAX_BUBBLES = 20; // Maximum number of bubbles allowed

        const recordButton = document.getElementById('recordButton');
        const voiceWall = document.getElementById('voiceWall');

        // Functions to persist data
        async function saveToLocalStorage() {
            const notesArray = [];
            
            for (const [id, note] of voiceNotes.entries()) {
                // Convert audio blob to base64 for storage
                let audioBase64 = null;
                if (note.audioBlob) {
                    audioBase64 = await blobToBase64(note.audioBlob);
                }
                
                notesArray.push({
                    id,
                    createdAt: note.createdAt.getTime(),
                    colorIndex: note.colorIndex,
                    audioBase64: audioBase64
                });
            }
            
            localStorage.setItem('voiceNotes', JSON.stringify(notesArray));
        }

        function blobToBase64(blob) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.onerror = reject;
                reader.readAsDataURL(blob);
            });
        }

        function base64ToBlob(base64) {
            const [header, data] = base64.split(',');
            const mimeType = header.match(/:(.*?);/)[1];
            const binary = atob(data);
            const bytes = new Uint8Array(binary.length);
            
            for (let i = 0; i < binary.length; i++) {
                bytes[i] = binary.charCodeAt(i);
            }
            
            return new Blob([bytes], { type: mimeType });
        }

        function loadFromLocalStorage() {
            const stored = localStorage.getItem('voiceNotes');
            if (!stored) return;

            try {
                const notesArray = JSON.parse(stored);
                const now = Date.now();

                notesArray.forEach(storedNote => {
                    const elapsed = now - storedNote.createdAt;
                    
                    // Only restore notes that haven't expired
                    if (elapsed < NOTE_LIFETIME) {
                        // Restore audio from base64
                        let audioUrl = null;
                        let audioBlob = null;
                        
                        if (storedNote.audioBase64) {
                            audioBlob = base64ToBlob(storedNote.audioBase64);
                            audioUrl = URL.createObjectURL(audioBlob);
                        }
                        
                        const note = {
                            id: storedNote.id,
                            createdAt: new Date(storedNote.createdAt),
                            colorIndex: storedNote.colorIndex,
                            audioUrl: audioUrl,
                            audioBlob: audioBlob
                        };
                        
                        voiceNotes.set(storedNote.id, note);
                        
                        // Create visual bubble with working audio
                        createVoiceNoteFromData(note);
                        
                        // Set remaining cleanup timer
                        const remaining = NOTE_LIFETIME - elapsed;
                        setTimeout(() => {
                            deleteVoiceNote(storedNote.id);
                        }, remaining);
                    }
                });
            } catch (error) {
                console.error('Error loading notes from localStorage:', error);
                localStorage.removeItem('voiceNotes');
            }
        }

        // Initialize social media links (replace with actual URLs)
        document.getElementById('tiktok-link').href = 'https://tiktok.com/@yourusername';
        document.getElementById('youtube-link').href = 'https://www.youtube.com/watch?v=s65-ac4rK-A&list=RDs65-ac4rK-A&start_radio=1';

        recordButton.addEventListener('click', toggleRecording);

        async function toggleRecording() {
            if (!isRecording) {
                await startRecording();
            } else {
                stopRecording();
            }
        }

        async function startRecording() {
            try {
                // More specific audio constraints for better desktop compatibility
                const constraints = {
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true,
                        sampleRate: 44100
                    }
                };

                console.log('🎤 Requesting microphone access...');
                const stream = await navigator.mediaDevices.getUserMedia(constraints);
                console.log('✅ Microphone access granted');

                // Check if MediaRecorder is supported
                if (!MediaRecorder.isTypeSupported('audio/webm')) {
                    console.log('audio/webm not supported, trying audio/mp4');
                    if (!MediaRecorder.isTypeSupported('audio/mp4')) {
                        console.log('audio/mp4 not supported, using default');
                    }
                }

                // Use the best supported format
                const mimeType = MediaRecorder.isTypeSupported('audio/webm') ? 'audio/webm' : 
                                MediaRecorder.isTypeSupported('audio/mp4') ? 'audio/mp4' : 
                                'audio/wav';

                mediaRecorder = new MediaRecorder(stream, { mimeType });
                audioChunks = [];

                mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        console.log('📊 Audio data received:', event.data.size, 'bytes');
                        audioChunks.push(event.data);
                    }
                };

                mediaRecorder.onstop = () => {
                    console.log('🛑 Recording stopped, creating blob...');
                    const audioBlob = new Blob(audioChunks, { type: mimeType });
                    console.log('📦 Audio blob created:', audioBlob.size, 'bytes');
                    
                    createVoiceNote(audioBlob);
                    stream.getTracks().forEach(track => track.stop());
                };

                mediaRecorder.onerror = (event) => {
                    console.error('❌ MediaRecorder error:', event.error);
                };

                mediaRecorder.start(1000); // Collect data every second for better compatibility
                isRecording = true;
                recordingStartTime = Date.now();

                recordButton.classList.add('recording');
                recordButton.innerHTML = '⏹️';
                console.log('🔴 Recording started...');
                
                // Start timer display
                recordingTimer = setInterval(updateRecordingTime, 100);

                // Auto-stop after max time
                setTimeout(() => {
                    if (isRecording) {
                        console.log('⏰ Auto-stopping recording after max time');
                        stopRecording();
                    }
                }, MAX_RECORDING_TIME);

            } catch (error) {
                console.error('❌ Error accessing microphone:', error);
                let errorMessage = 'No se pudo acceder al micrófono. ';
                
                if (error.name === 'NotAllowedError') {
                    errorMessage += 'Por favor permite el acceso al micrófono y recarga la página.';
                } else if (error.name === 'NotFoundError') {
                    errorMessage += 'No se encontró micrófono conectado.';
                } else if (error.name === 'NotSupportedError') {
                    errorMessage += 'Tu navegador no soporta grabación de audio.';
                } else {
                    errorMessage += 'Error: ' + error.message;
                }
                
                alert(errorMessage);
            }
        }

        function stopRecording() {
            if (mediaRecorder && isRecording) {
                mediaRecorder.stop();
                isRecording = false;

                recordButton.classList.remove('recording');
                recordButton.innerHTML = '🎤';

                clearInterval(recordingTimer);
            }
        }

        function updateRecordingTime() {
            // Timer functionality removed as requested
        }

        async function createVoiceNote(audioBlob) {
            try {
                // Create audio URL from blob for local playback
                const audioUrl = URL.createObjectURL(audioBlob);
                const noteId = `note-${noteIdCounter}`;
                const createdAt = new Date();
                const colorIndex = Math.floor(Math.random() * 8) + 1;

                const voiceNote = {
                    id: noteId,
                    audioUrl: audioUrl,
                    audioBlob: audioBlob,
                    createdAt: createdAt,
                    colorIndex: colorIndex
                };

                // Check if we need to remove oldest bubble to maintain limit
                if (voiceNotes.size >= MAX_BUBBLES) {
                    removeOldestBubble();
                }

                // Store locally in memory and localStorage
                voiceNotes.set(noteId, voiceNote);
                await saveToLocalStorage();

                // Create visual note
                createVoiceNoteFromData(voiceNote);

                // Increment counter after creating note
                noteIdCounter++;

                // Set cleanup timer
                setTimeout(() => {
                    deleteVoiceNote(noteId);
                }, NOTE_LIFETIME);

                console.log('Voice note created successfully:', noteId);

            } catch (error) {
                console.error('Error creating voice note:', error);
                alert('Failed to create voice note. Please try again.');
            }
        }

        function createVoiceNoteFromData(note) {
            // Don't create if already exists
            if (document.getElementById(`note-${note.id}`)) {
                return;
            }

            const createdAt = note.createdAt;
            const voiceBubble = document.createElement('div');
            voiceBubble.className = `voice-bubble bubble-color-${note.colorIndex}`;
            voiceBubble.id = `note-${note.id}`;

            voiceBubble.innerHTML = `
                <div class="voice-time">${formatTime(createdAt)}</div>
                <div class="timer-overlay" id="timer-${note.id}">09:59</div>
                <button class="respond-button" onclick="respondToNote('${note.id}')">
                    Reply
                </button>
            `;

            // Add click event to play audio when bubble is clicked
            voiceBubble.addEventListener('click', () => {
                playAudio(note.audioUrl);
            });

            // Add with entrance animation
            voiceBubble.style.transform = 'scale(0) rotate(180deg)';
            voiceBubble.style.opacity = '0';
            voiceWall.appendChild(voiceBubble);

            // Animate entrance
            setTimeout(() => {
                voiceBubble.style.transform = 'scale(1) rotate(0deg)';
                voiceBubble.style.opacity = '1';
            }, 100);

            // Start countdown timer
            startNoteTimer(note.id, createdAt);
        }

        function startNoteTimer(noteId, createdAt) {
            const timer = setInterval(() => {
                const elapsed = Date.now() - createdAt.getTime();
                const remaining = NOTE_LIFETIME - elapsed;

                if (remaining <= 0) {
                    clearInterval(timer);
                    deleteVoiceNote(noteId);
                    return;
                }

                // Update timer display
                const minutes = Math.floor(remaining / 60000);
                const seconds = Math.floor((remaining % 60000) / 1000);
                const timerElement = document.getElementById(`timer-${noteId}`);
                if (timerElement) {
                    timerElement.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                    
                    // Add urgency effect when less than 2 minutes
                    if (remaining < 120000) {
                        timerElement.style.color = '#ff6b6b';
                        timerElement.style.animation = 'pulse 1s infinite';
                    }
                }
            }, 1000);
        }

        async function deleteVoiceNote(noteId) {
            const note = voiceNotes.get(noteId);
            if (!note) return;

            // Revoke blob URLs to free memory
            URL.revokeObjectURL(note.audioUrl);

            // Remove from memory
            voiceNotes.delete(noteId);
            
            // Update localStorage
            await saveToLocalStorage();

            // Remove from DOM with animation
            const noteElement = document.getElementById(`note-${noteId}`);
            if (noteElement) {
                noteElement.classList.add('exploding');
                setTimeout(() => {
                    noteElement.remove();
                }, 800);
            }
            
            console.log(`Voice note ${noteId} deleted`);
        }

        function removeOldestBubble() {
            if (voiceNotes.size === 0) return;

            // Find the oldest note by creation time
            let oldestNote = null;
            let oldestTime = Date.now();

            for (const [id, note] of voiceNotes.entries()) {
                if (note.createdAt.getTime() < oldestTime) {
                    oldestTime = note.createdAt.getTime();
                    oldestNote = { id, note };
                }
            }

            if (oldestNote) {
                console.log(`🗑️ Removing oldest bubble ${oldestNote.id} to maintain ${MAX_BUBBLES} bubble limit`);
                deleteVoiceNote(oldestNote.id);
            }
        }

        async function playAudio(audioUrl) {
            if (!audioUrl) {
                console.error('❌ No audio URL provided');
                alert('No hay audio para reproducir');
                return;
            }

            // Stop any currently playing audio with delay
            if (currentlyPlayingAudio && !currentlyPlayingAudio.paused) {
                console.log('⏹️ Stopping previous audio');
                currentlyPlayingAudio.pause();
                currentlyPlayingAudio.currentTime = 0;
                currentlyPlayingAudio = null;
                
                // Small delay to prevent "operation was aborted" error
                await new Promise(resolve => setTimeout(resolve, 100));
            }

            console.log('🔊 Attempting to play audio:', audioUrl);
            const audio = new Audio(audioUrl);
            
            // Set up all event listeners before setting as current
            audio.addEventListener('loadstart', () => console.log('📋 Audio loading started'));
            audio.addEventListener('canplay', () => console.log('✅ Audio can play'));
            audio.addEventListener('ended', () => {
                console.log('🏁 Audio playback finished');
                if (currentlyPlayingAudio === audio) {
                    currentlyPlayingAudio = null;
                }
            });
            audio.addEventListener('error', (e) => {
                console.error('❌ Audio error:', e);
                if (currentlyPlayingAudio === audio) {
                    currentlyPlayingAudio = null;
                }
                alert('Error al reproducir audio: ' + (e.message || 'Desconocido'));
            });
            
            // Set as current audio only after setup
            currentlyPlayingAudio = audio;
            
            // Try to play with proper error handling
            try {
                await audio.play();
                console.log('🎵 Audio playing successfully');
            } catch (error) {
                console.error('❌ Error playing audio:', error);
                
                // Clear current audio on error
                if (currentlyPlayingAudio === audio) {
                    currentlyPlayingAudio = null;
                }
                
                // Specific error handling
                if (error.name === 'NotAllowedError') {
                    alert('Por favor permite la reproducción de audio y haz click en la página primero.');
                } else if (error.name === 'AbortError') {
                    console.log('⚠️ Audio playback was aborted - this is normal when switching between audios');
                    // Don't show alert for abort errors as they're expected
                } else {
                    alert('Error al reproducir audio: ' + error.message);
                }
            }
        }

        function respondToNote(noteId) {
            // Use Reply button to play the audio instead of recording
            const note = voiceNotes.get(noteId);
            if (note && note.audioUrl) {
                playAudio(note.audioUrl);
            }
        }

        function formatTime(date) {
            return date.toLocaleTimeString('en-US', { 
                hour: '2-digit', 
                minute: '2-digit',
                hour12: true 
            });
        }

        // Mobile detection and canvas setup
        function isMobile() {
            return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        }

        // Initialize app
        window.addEventListener('load', async () => {
            // Load existing notes from localStorage
            loadFromLocalStorage();
            
            // Show canvas on mobile
            if (isMobile()) {
                document.getElementById('mobileCanvas').style.display = 'block';
                setupMobileCanvas();
            }

            // Check microphone permissions
            try {
                const permission = await navigator.permissions.query({ name: 'microphone' });
                console.log('🎤 Microphone permission state:', permission.state);
                if (permission.state === 'denied') {
                    console.log('❌ Microphone access denied');
                }
            } catch (error) {
                console.log('⚠️ Permission API not supported');
            }

            // Add click handler to enable audio context for desktop browsers
            document.addEventListener('click', enableAudioContext, { once: true });
        });

        function enableAudioContext() {
            console.log('👆 User interaction detected - audio context enabled');
            // This helps with desktop audio playback restrictions
        }

        function setupMobileCanvas() {
            const canvas = document.getElementById('mobileCanvas');
            const ctx = canvas.getContext('2d');
            
            // Set canvas size
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;

            // Draw mobile-friendly visualization
            function drawWaveform() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                const centerY = canvas.height / 2;
                const barWidth = 4;
                const barCount = Math.floor(canvas.width / (barWidth + 2));
                
                for (let i = 0; i < barCount; i++) {
                    const height = Math.random() * 80 + 20;
                    const x = i * (barWidth + 2);
                    
                    ctx.fillStyle = `rgba(255, 255, 255, ${Math.random() * 0.3 + 0.1})`;
                    ctx.fillRect(x, centerY - height/2, barWidth, height);
                }
                
                if (isRecording) {
                    requestAnimationFrame(drawWaveform);
                }
            }

            // Start animation when recording on mobile
            const originalStartRecording = startRecording;
            window.startRecording = async function() {
                await originalStartRecording();
                if (isMobile() && isRecording) {
                    drawWaveform();
                }
            };
        }
        
        // Script para generar hojas cayendo
        function createFallingLeaf() {
            const leaf = document.createElement('div');
            leaf.className = 'leaf';
            leaf.innerHTML = Math.random() > 0.5 ? '🍂' : '🍃';
            
            // Posición aleatoria en el ancho de la pantalla
            leaf.style.left = Math.random() * 100 + '%';
            
            // Retraso aleatorio para cada hoja
            leaf.style.animationDelay = Math.random() * 5 + 's';
            
            // Añadir ligera variación en la duración
            const baseDuration = parseFloat(getComputedStyle(leaf).animationDuration);
            leaf.style.animationDuration = (baseDuration + (Math.random() - 0.5) * 4) + 's';
            
            document.getElementById('falling-leaves').appendChild(leaf);
            
            // Remover la hoja después de que termine la animación
            setTimeout(() => {
                if (leaf.parentNode) {
                    leaf.parentNode.removeChild(leaf);
                }
            }, 20000);
        }
        
        // Crear hojas cayendo cada cierto tiempo
        setInterval(createFallingLeaf, 1600);
        
        // Crear algunas hojas iniciales
        for (let i = 0; i < 4; i++) {
            setTimeout(createFallingLeaf, i * 1200);
        }
    </script>
</body>
</html>